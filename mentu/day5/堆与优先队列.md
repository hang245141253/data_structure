# 堆与优先队列

## 堆的基础知识

### 完全二叉树回顾

回顾完全二叉树，与堆之间非常暧昧

![alt text](../day4/image-8.png)

完全二叉树可以用连续的数组空间进行存储，因为完全二叉树中父节点与子节点的编号是有关系的。因为子节点的编号可以通过父节点的编号计算得到，所以完全二叉树就没有必要存储边的信息。

    父节点i从1开始：
        左孩子：2i
        右孩子：2i + 1

    父节点i从0开始：
        左孩子：2i + 1
        右孩子：2i + 2 

思维上是完全二叉树，但是实际代码实现是一个数组，我们要看着数组把他想成完全二叉树

![alt text](image.png)

练习看着数组画出完全二叉树。

### 堆

![alt text](image-2.png)

    堆的性质：任意的三元组（父节点与其两个子节点）
        如果所有父节点都大于两个子节点，则是大顶堆，堆顶元素则是最大值。
        如果所有父节点都小于两个子节点，则是小顶堆，堆顶元素则是最小值。

    那么，大顶堆中，
    Q:第二大的值在哪里？
    A:第二层

    Q:第三大的值在哪里？
    A:第二层或者第三层

因为只有父子之间才有明确的大小关系、兄弟之间是没有的。

在第三层的节点从性质上肯定得出一定会用两个元素大于第三层的节点。

    所有第三层的点都有可能是第三大的值，比如：

![alt text](image-1.png)

    第四大的值则第四大的值可能在2、3、4层： 

![alt text](image-3.png)

    第五大的值可能在2、3、4、5层，以此类推...

小顶堆性质雷同


### 堆--尾部插入调整

![alt text](image-4.png)

插入元素肯定是在数组的末尾添加，但是添加以后有可能会违反堆的性质，需要进行插入调整：

    每次都（通过数组下标计算出父节点的编号）跟当前的爹(父节点)比，如果比父节点大，则swap(我，父节点)（成为新的爸爸），直到成为整个树的根节点或者遇到比自己大的父节点。 (向上调整)

![alt text](image-9.png)

    直到符合堆的性质为止

![alt text](image-5.png)
---

**强化数据结构的概念理解：结构定义+结构操作**

用堆来举例子

    结构定义：堆是基于完全二叉树的，所以它是一种树型结构
    结构定义还包含性质：任意三元组，根要比其左右节点大（或小）

    结构操作：堆基本操作插入、删除
    但是重点需要关注的是如何维护这个数据结构的性质

所以，数据结构做的事情一句话概括：
    定义一种性质，维护这种性质。（数据结构的精髓）

### 堆--头部弹出调整

    弹出的是堆顶元素

![alt text](image-6.png)

    弹出后，有效元素从10个变成9个，元素7位置越界，将其调整到堆顶，然后进行向下调整

![alt text](image-7.png)

    寻找当前三元组的最大(小)值，然后将父节点与其交换，直到满足堆的性质为止。

![alt text](image-8.png)

### 堆排序



## 堆的经典题目-堆的基本操作

## 堆的经典题目-堆的进阶操作

## 哈夫曼编码